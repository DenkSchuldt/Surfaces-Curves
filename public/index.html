<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>Surfaces and Curves</title>
		<style>
			body { 
				margin: 0; 
				overflow: hidden;
			}
		</style>
	</head>
	<body>
		<script src="js/three.min.js"></script>
		<script src="js/OrbitControls.js"></script>
		<script>

			var scene, camera, renderer;
			var PI = 3.1416;
			var WIDTH, HEIGHT;

			var opening = false;
			var closing = false;
			var open = false;
			var clickingTop = false;

			var plane;
			var objects = [];
			var cover = new THREE.Object3D();
			var raycaster = new THREE.Raycaster();
			var mouseVector = new THREE.Vector2();
			var mouseUpVector = new THREE.Vector2();
			var mouseDownVector = new THREE.Vector2();
			var mouseMoveVector = new THREE.Vector2();
			var intersectsMouse;
			var initTime = Date.now();

			var pathLinePoints = 15000; //Cantidad de puntos que tendra el segmento dibujado de la curva de bezier
			var point1 = new THREE.Vector3(100,100,5); //Punto inicial de la curva de bezier
		  	var point2 = new THREE.Vector3(-210,-20,-180);
		  	var point3 = new THREE.Vector3(200,53,200);
		  	var point4 = new THREE.Vector3(1,5,2); //Punto final de la curva de bezier

		/**
	     * 
	     */
	    function init() {
	    	scene = new THREE.Scene();
	     	WIDTH = window.innerWidth;
				HEIGHT = window.innerHeight;

	      renderer = new THREE.WebGLRenderer({antialias:true});
	      renderer.setSize(WIDTH, HEIGHT);
	      document.body.appendChild(renderer.domElement);

	      camera = new THREE.PerspectiveCamera(45, WIDTH / HEIGHT, 0.1, 20000);
	      camera.position.set(0,6,0);
	      camera.lookAt(scene.position);//Apuntamos el FOV de la camara hacia la escena
	      scene.add(camera);

	      window.addEventListener('resize', function() {
	        WIDTH = window.innerWidth;
	        HEIGHT = window.innerHeight;
	        renderer.setSize(WIDTH, HEIGHT);
	        camera.aspect = WIDTH / HEIGHT;
	        camera.updateProjectionMatrix();
	      });

	      window.addEventListener( 'mousedown', onMouseDown );
				window.addEventListener( 'mouseup', onMouseUp );
				window.addEventListener( 'mousemove', onMouseMove);

	      renderer.setClearColor(0x333F47, 1);

				var ambientLight = new THREE.AmbientLight(0x999999);
				scene.add(ambientLight);
		  renderer.shadowMapEnabled = true;
		  renderer.shadowMapType = THREE.PCFSoftShadowMap;
	      controls = new THREE.OrbitControls(camera, renderer.domElement);

	      drawBezierPath(point1, point2, point3, point4);
	      createCube();
	      createCover();
	      createObjectCube();
	      createObjectSphere();
	      createObjectPyramid();
	      createSpotlight();
	    }

			/**
	     * 
	     */
	    function animate() {
	      requestAnimationFrame(animate);
	      renderer.render(scene, camera);
	      controls.update();
	      time = parseInt(Date.now() - initTime);
	      segmentPoints = createBezierCurveSegmentPoints(point1, point2, point3, point4);

				if(opening && cover.rotation.x>0.25*PI){
					cover.rotation.x -= 0.02;
				}else if (opening){
					opening = false;
					open = true;
				}
				
				if(closing && cover.rotation.x<0.5*PI){
					cover.rotation.x += 0.02;
				}else if (closing){
					closing = false;
					open = false;
				}

				if (time<pathLinePoints){ //Mientras el tiempo transcurrido sea menor al numero de puntos en el segmento de la curva de bezier
					camera.position.x = segmentPoints[time].x;//Se obtiene el valor de X, Y y Z de un punto del segmento
					camera.position.y = segmentPoints[time].y;//de acuerdo al tiempo transcurrido para posicionar la camara en ese punto
					camera.position.z = segmentPoints[time].z;
		  		}
	    }
		
	    /**
	     *
	     */	
	    function createCube() {
	    	var boxMaterial1 = new THREE.MeshPhongMaterial({ 
	    				side: THREE.FrontSide, 
	    				shading: THREE.SmoothShading,
	    		  	map: THREE.ImageUtils.loadTexture('img/cube/side.png') 
	    			});
				var boxMaterial2 = new THREE.MeshPhongMaterial({ 
							side: THREE.FrontSide, 
							shading: THREE.SmoothShading,
				  		map: THREE.ImageUtils.loadTexture('img/cube/side.png') 
						});
				var boxMaterial3 = new THREE.MeshPhongMaterial({ 
							side: THREE.FrontSide, 
							opacity: 0, 
							transparent: true,
							shading: THREE.SmoothShading,
							map: THREE.ImageUtils.loadTexture('img/cube/top.png')
						});
				var boxMaterial4 = new THREE.MeshPhongMaterial({ 
							side: THREE.FrontSide, 
							shading: THREE.SmoothShading,
							map: THREE.ImageUtils.loadTexture('img/cube/side.png')
						});
				var boxMaterial5 = new THREE.MeshPhongMaterial({ 
							side: THREE.FrontSide, 
							shading: THREE.SmoothShading,
							map: THREE.ImageUtils.loadTexture('img/cube/front.png') 
						});
				var boxMaterial6 = new THREE.MeshPhongMaterial({ 
							side: THREE.FrontSide, 
							shading: THREE.SmoothShading,
							map: THREE.ImageUtils.loadTexture('img/cube/back.png') 
						});
				var boxMaterialBack = new THREE.MeshPhongMaterial({ 
							side: THREE.BackSide,
							shading: THREE.SmoothShading,
							map: THREE.ImageUtils.loadTexture('img/cube/side.png') 
						});

				var boxMaterials = [
						boxMaterial1, 
						boxMaterial2, 
						boxMaterial3, 
						boxMaterial4, 
						boxMaterial5, 
						boxMaterial6,
						boxMaterialBack];

				var boxFaceMaterial = new THREE.MeshFaceMaterial( boxMaterials );
				var boxGeometry = new THREE.BoxGeometry( 1, 1, 1 );
		
				for (var i = 0, len = boxGeometry.faces.length; i < len; i++) {
					var face = boxGeometry.faces[i].clone();
							face.materialIndex = 6;
					boxGeometry.faces.push(face);
					boxGeometry.faceVertexUvs[0].push(boxGeometry.faceVertexUvs[0][i].slice(0));
				}

				var cube = new THREE.Mesh( boxGeometry, boxFaceMaterial );
				cube.receiveShadow = true;
				scene.add( cube );
	    }

	    /**
	     *
	     */
	    function createCover() {
				var planeGeom = new THREE.PlaneGeometry(1, 1, 2, 2);
				var planeMat1 = new THREE.MeshPhongMaterial({ 
							side: THREE.DoubleSide, 
							map: THREE.ImageUtils.loadTexture('img/cube/side.png') 
						});
				var planeMat2 = new THREE.MeshPhongMaterial({ 
							side: THREE.FrontSide, 
							map: THREE.ImageUtils.loadTexture('img/cube/top.png') 
						});			
				
				var planeMaterials = [
							planeMat1, 
							planeMat2 ];
				
				var planeFaceMaterial = new THREE.MeshFaceMaterial( planeMaterials );

				plane = new THREE.Mesh(planeGeom , planeMat1);
				plane.rotation.x=0;
				plane.position.x=0;
				plane.position.y=0;
				plane.position.z=0; 
				plane.applyMatrix( new THREE.Matrix4().makeTranslation( 0, 0.5, 0 ) );
				plane.castShadow = true;

				cover.add(plane);
				cover.position.y=0.5;
				cover.position.z=-0.5;
				cover.rotation.x = 0.5*PI;
				scene.add(cover);

				objects.push( cover );
	    }

	    /**
	     *
	     */
			function onMouseDown( e ) {
				mouseVector.x = 2 * (e.clientX / window.innerWidth) - 1;
				mouseVector.y = 1 - 2 * ( e.clientY / window.innerHeight );
				mouseDownVector.x = 2 * (e.clientX / window.innerWidth) - 1;
				mouseDownVector.y = 1 - 2 * ( e.clientY / window.innerHeight );
				raycaster.setFromCamera( mouseDownVector, camera );
				intersectsMouse = raycaster.intersectObjects( objects , true);
				if (intersectsMouse.length>0){
					if(intersectsMouse[0].object.position==plane.position){
						clickingTop = true;
					}
				}
			}
			
			/**
			 *
			 */
			function onMouseUp( e ) {
				mouseUpVector.x = 2 * (e.clientX / window.innerWidth) - 1;
				mouseUpVector.y = 1 - 2 * ( e.clientY / window.innerHeight );
				if (mouseDownVector.x == mouseUpVector.x && mouseDownVector.y == mouseUpVector.y){
					raycaster.setFromCamera( mouseDownVector, camera );
					var intersects = raycaster.intersectObjects( objects , true);
					if (intersects.length>0){
						if(intersects[0].object.position==plane.position && opening == false && open==false){
							opening = true;
						}
						if(intersects[0].object.position==plane.position && closing == false && open==true){
							closing = true;
						}
					}
				}
				clickingTop = false;
			}
			
			/**
			 *
			 */
			function onMouseMove (e){
				mouseMoveVector.x = 2 * (e.clientX / window.innerWidth) - 1;
				mouseMoveVector.y = 1 - 2 * ( e.clientY / window.innerHeight );
				if (mouseVector.x != mouseMoveVector.x && mouseVector.y != mouseMoveVector.y && clickingTop == true){
					if(mouseVector.y < mouseMoveVector.y && cover.rotation.x>0.25*3.1416){
						cover.rotation.x -= 0.1;
					}
					if(mouseVector.y > mouseMoveVector.y && cover.rotation.x<0.5*3.1416){
						cover.rotation.x += 0.1;
					}
				}
				mouseVector.x = 2 * (e.clientX / window.innerWidth) - 1;
				mouseVector.y = 1 - 2 * ( e.clientY / window.innerHeight );
			}

			/**
			 *
			 */
			function createObjectCube(){
				var cubeGeom = new THREE.CubeGeometry(0.3, 0.3, 0.3);//definimos las dimensiones del cubo x, y, z
				var cubeMat = new THREE.MeshPhongMaterial({
					shininess	: 300, 
					specular	: 0x33AA33,
					shading 	: THREE.SmoothShading, 
					map 		: THREE.ImageUtils.loadTexture('img/objects/marble.jpg')
				}); //inicializamos una textura de marmol
				var cube = new THREE.Mesh(cubeGeom, cubeMat);//juntamos la textura y la forma para obtener el objeto
				cube.receiveShadow = true;
				cube.castShadow = true;
				cube.position.x=0.25;//definimos la posición inicial
				cube.position.y=0.1;
				cube.position.z=0.25;
				scene.add(cube);
			}

			/**
			 *
			 */
			function createObjectSphere(){
				var sphereGeom = new THREE.SphereGeometry(0.2, 20, 20); //Definimos las dimensiones de la esfera
				var sphereMat = new THREE.MeshPhongMaterial({
					shininess	: 300, 
					specular	: 0x33AA33,
					shading 	: THREE.SmoothShading,
					map 		:  THREE.ImageUtils.loadTexture('img/objects/gold.png')
				});//inicializamos textura de oro
				var sphere = new THREE.Mesh(sphereGeom, sphereMat);//las juntamos en una figura
				sphere.receiveShadow = true;
				sphere.castShadow = true;
				sphere.rotation.z=2;//Rotamos la esfera para ocultar la union radial de la textura
				sphere.position.x=-0.15;//definimos la posición inicial
				sphere.position.y=-0.1;
				sphere.position.z=0.2;
				scene.add(sphere);
			}

			 /**
			 *
			 */
			function createObjectPyramid(){
				var pyramidGeom = new THREE.CylinderGeometry( 0, 0.3, 0.6, 4, 1 );//definimos las dimensiones de un cilindro, donde 4 representa el numero de puntos de la base y 0 representa n+1 puntos de la cara superior, obteniendo una pirámide de base cuadrada
				var pyramidMat = new THREE.MeshPhongMaterial({
					specular	: 0x33AA33,
					shading 	: THREE.SmoothShading,
					map 		: THREE.ImageUtils.loadTexture('img/objects/block.jpg')
				}); //creamos una textura de bloques
				var pyramid = new THREE.Mesh(pyramidGeom, pyramidMat);//juntamos las dimensiones geométricas con la textura
				pyramid.receiveShadow = true;
				pyramid.castShadow = true;
				pyramid.rotation.y=1;
				pyramid.position.x=0.2;//definimos la posición inicial de la figura.
				pyramid.position.y=0.1;
				pyramid.position.z=-0.16;
				scene.add(pyramid);
			}

			/**
			 *
			 */
			function createSpotlight(){
				var spotlight = new THREE.SpotLight( 0xFFAA88);
				spotlight.target.position.set(0,0,0);
				spotlight.position.set(0,100, 0); //definimos la posicion la de luz artificial
				spotlight.castShadow = true;
				spotlight.shadowDarkness = 2;
				scene.add(spotlight);
			}

			/**
			 *
			 */
			function createBezierCurveSegmentPoints(point1, point2, point3, point4){
				var bezierCurve = new THREE.CubicBezierCurve3(point1, point2, point3, point4); //Se crea una curva de bezier con los puntos dados
				var curvePoints = bezierCurve.getPoints(pathLinePoints); //Se obtienen los puntos de la curva creada, para crear la trayectoria de la camara
				return curvePoints;
			}

			/**
			 *
			 */
			function drawBezierPath(point1, point2, point3, point4){
		 		var bezierPathGeom = new THREE.Geometry();
		  		var bezierPathMat = new THREE.LineBasicMaterial({ color: 0xff6666 });
		  		segmentPoints = createBezierCurveSegmentPoints(point1, point2, point3, point4);
		  		for(var i = 0; i < segmentPoints.length; i++){ //Para cada punto del segmento de la curva de bezier
		  			bezierPathGeom.vertices.push(segmentPoints[i]);  //Se agrega dicho punto a la geometria del dibujo de la curva como vertice
		  		}
		  		var bezierPath = new THREE.Line(bezierPathGeom, bezierPathMat); //Se crea una linea con la geometria especificada y un material simple
		  		scene.add(bezierPath);
			}

			init();
			animate();

		</script>
	</body>
</html>