<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>Surfaces and Curves</title>
		<style>
			body { 
				margin: 0; 
				overflow: hidden;
			}
		</style>
	</head>
	<body>
		<script src="js/three.min.js"></script>
		<script src="js/OrbitControls.js"></script>
		<script>

			var scene, camera, renderer;
			var PI = 3.1416;
			var WIDTH, HEIGHT;

			var opening = false;
			var closing = false;
			var open = false;
			var clickingTop = false;

			var plane;
			var objects = [];
			var cover = new THREE.Object3D();
			var raycaster = new THREE.Raycaster();
			var mouseVector = new THREE.Vector2();
			var mouseUpVector = new THREE.Vector2();
			var mouseDownVector = new THREE.Vector2();
			var mouseMoveVector = new THREE.Vector2();
			var intersectsMouse;

			/**
	     * 
	     */
	    function init() {
	    	scene = new THREE.Scene();
	     	WIDTH = window.innerWidth;
				HEIGHT = window.innerHeight;

	      renderer = new THREE.WebGLRenderer({antialias:true});
	      renderer.setSize(WIDTH, HEIGHT);
	      document.body.appendChild(renderer.domElement);

	      camera = new THREE.PerspectiveCamera(45, WIDTH / HEIGHT, 0.1, 20000);
	      camera.position.set(0,6,0);
	      scene.add(camera);

	      window.addEventListener('resize', function() {
	        WIDTH = window.innerWidth;
	        HEIGHT = window.innerHeight;
	        renderer.setSize(WIDTH, HEIGHT);
	        camera.aspect = WIDTH / HEIGHT;
	        camera.updateProjectionMatrix();
	      });

	      window.addEventListener( 'mousedown', onMouseDown );
				window.addEventListener( 'mouseup', onMouseUp );
				window.addEventListener( 'mousemove', onMouseMove);

	      renderer.setClearColor(0x333F47, 1);

				var ambientLight = new THREE.AmbientLight(0x999999);
				scene.add(ambientLight);

	      controls = new THREE.OrbitControls(camera, renderer.domElement);

	      createCube();
	      createCover();
	    }

			/**
	     * 
	     */
	    function animate() {
	      requestAnimationFrame(animate);
	      renderer.render(scene, camera);
	      controls.update();

				if(opening && cover.rotation.x>0.25*PI){
					cover.rotation.x -= 0.02;
				}else if (opening){
					opening = false;
					open = true;
				}
				
				if(closing && cover.rotation.x<0.5*PI){
					cover.rotation.x += 0.02;
				}else if (closing){
					closing = false;
					open = false;
				}
	    }

	    /**
	     *
	     */	
	    function createCube() {
	    	var boxMaterial1 = new THREE.MeshPhongMaterial({ 
	    				side: THREE.FrontSide, 
	    		  	map: THREE.ImageUtils.loadTexture('img/cube/side.png') 
	    			});
				var boxMaterial2 = new THREE.MeshPhongMaterial({ 
							side: THREE.FrontSide, 
				  		map: THREE.ImageUtils.loadTexture('img/cube/side.png') 
						});
				var boxMaterial3 = new THREE.MeshPhongMaterial({ 
							side: THREE.FrontSide, 
							opacity: 0, 
							transparent: true, 
							map: THREE.ImageUtils.loadTexture('img/cube/top.png')
						});
				var boxMaterial4 = new THREE.MeshPhongMaterial({ 
							side: THREE.FrontSide, 
							map: THREE.ImageUtils.loadTexture('img/cube/side.png')
						});
				var boxMaterial5 = new THREE.MeshPhongMaterial({ 
							side: THREE.FrontSide, 
							map: THREE.ImageUtils.loadTexture('img/cube/front.png') 
						});
				var boxMaterial6 = new THREE.MeshPhongMaterial({ 
							side: THREE.FrontSide, 
							map: THREE.ImageUtils.loadTexture('img/cube/back.png') 
						});
				var boxMaterialBack = new THREE.MeshPhongMaterial({ 
							side: THREE.BackSide, 
							map: THREE.ImageUtils.loadTexture('img/cube/side.png') 
						});

				var boxMaterials = [
						boxMaterial1, 
						boxMaterial2, 
						boxMaterial3, 
						boxMaterial4, 
						boxMaterial5, 
						boxMaterial6,
						boxMaterialBack];

				var boxFaceMaterial = new THREE.MeshFaceMaterial( boxMaterials );
				var boxGeometry = new THREE.BoxGeometry( 1, 1, 1 );
		
				for (var i = 0, len = boxGeometry.faces.length; i < len; i++) {
					var face = boxGeometry.faces[i].clone();
							face.materialIndex = 6;
					boxGeometry.faces.push(face);
					boxGeometry.faceVertexUvs[0].push(boxGeometry.faceVertexUvs[0][i].slice(0));
				}

				var cube = new THREE.Mesh( boxGeometry, boxFaceMaterial );
				scene.add( cube );
	    }

	    /**
	     *
	     */
	    function createCover() {
				var planeGeom = new THREE.PlaneGeometry(1, 1, 2, 2);
				var planeMat1 = new THREE.MeshPhongMaterial({ 
							side: THREE.DoubleSide, 
							map: THREE.ImageUtils.loadTexture('img/cube/side.png') 
						});
				var planeMat2 = new THREE.MeshPhongMaterial({ 
							side: THREE.FrontSide, 
							map: THREE.ImageUtils.loadTexture('img/cube/top.png') 
						});			
				
				var planeMaterials = [
							planeMat1, 
							planeMat2 ];
				
				var planeFaceMaterial = new THREE.MeshFaceMaterial( planeMaterials );

				plane = new THREE.Mesh(planeGeom , planeMat1);
				plane.rotation.x=0;
				plane.position.x=0;
				plane.position.y=0;
				plane.position.z=0; 
				plane.applyMatrix( new THREE.Matrix4().makeTranslation( 0, 0.5, 0 ) );

				cover.add(plane);
				cover.position.y=0.5;
				cover.position.z=-0.5;
				cover.rotation.x = 0.5*PI;
				scene.add(cover);

				objects.push( cover );
	    }

	    /**
	     *
	     */
			function onMouseDown( e ) {
				mouseVector.x = 2 * (e.clientX / window.innerWidth) - 1;
				mouseVector.y = 1 - 2 * ( e.clientY / window.innerHeight );
				mouseDownVector.x = 2 * (e.clientX / window.innerWidth) - 1;
				mouseDownVector.y = 1 - 2 * ( e.clientY / window.innerHeight );
				raycaster.setFromCamera( mouseDownVector, camera );
				intersectsMouse = raycaster.intersectObjects( objects , true);
				if (intersectsMouse.length>0){
					if(intersectsMouse[0].object.position==plane.position){
						clickingTop = true;
					}
				}
			}
			
			/**
			 *
			 */
			function onMouseUp( e ) {
				mouseUpVector.x = 2 * (e.clientX / window.innerWidth) - 1;
				mouseUpVector.y = 1 - 2 * ( e.clientY / window.innerHeight );
				if (mouseDownVector.x == mouseUpVector.x && mouseDownVector.y == mouseUpVector.y){
					raycaster.setFromCamera( mouseDownVector, camera );
					var intersects = raycaster.intersectObjects( objects , true);
					if (intersects.length>0){
						if(intersects[0].object.position==plane.position && opening == false && open==false){
							opening = true;
						}
						if(intersects[0].object.position==plane.position && closing == false && open==true){
							closing = true;
						}
					}
				}
				clickingTop = false;
			}
			
			/**
			 *
			 */
			function onMouseMove (e){
				mouseMoveVector.x = 2 * (e.clientX / window.innerWidth) - 1;
				mouseMoveVector.y = 1 - 2 * ( e.clientY / window.innerHeight );
				if (mouseVector.x != mouseMoveVector.x && mouseVector.y != mouseMoveVector.y && clickingTop == true){
					if(mouseVector.y < mouseMoveVector.y && cover.rotation.x>0.25*3.1416){
						cover.rotation.x -= 0.1;
					}
					if(mouseVector.y > mouseMoveVector.y && cover.rotation.x<0.5*3.1416){
						cover.rotation.x += 0.1;
					}
				}
				mouseVector.x = 2 * (e.clientX / window.innerWidth) - 1;
				mouseVector.y = 1 - 2 * ( e.clientY / window.innerHeight );
			}


			init();
			animate();

		</script>
	</body>
</html>