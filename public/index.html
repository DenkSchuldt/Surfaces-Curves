<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>Surfaces and Curves</title>
		<style>
			body { 
				margin: 0;
				padding: 0;
				overflow: hidden;
			}
			.options {
				background: rgba(255,255,255, 0.2);
				position: fixed;
				margin: 0;
				padding: 15px;
				top: 15px;
				right: 15px;
				font-size: 1em;
				font-family: arial;
				border-radius: 3px;
			}
				.options h3 {
					margin: 0;
					padding: 0 0 10px 0;
					border-bottom: 1px solid #999;
				}
				.options h4 { margin-bottom: 0; }
				.options ul { 
					margin-top: 5px; 
					padding: 0;
				}
				.options .option { 
					list-style-type: none;
					margin-top: 5px;
					padding: 10px;
					cursor: pointer;
					margin-top: -5px;
					border-radius: 3px;
				}
				.options .option:hover {
					background-color: #fff!important;
				}
		</style>
	</head>
	<body>
		<div class="options">
			<h3>Rendering options:</h3>
			<h4>Cover movement:</h4>
			<ul>
				<li class="option automatic">Automatic</li>
				<li class="option manual">Manual</li>
			</ul>
			<h4>Standard camera movement:</h4>
			<ul>
				<li class="option standard-object">Looking to the object</li>
				<li class="option standard-x-axis">Perpendicular to X axis</li>
			</ul>
			<h4>Bezier camera movement:</h4>
			<ul>
				<li class="option bezier-object">Looking to the object</li>
				<li class="option bezier-x-axis">Perpendicular to X axis</li>
				<li class="option bezier-curve">Perpendicular to the curve</li>
			</ul>
		</div>
		<script src="js/three.min.js"></script>
		<script src="js/OrbitControls.js"></script>
		<script src="js/jquery-2.1.4.min.js"></script>
		<script>

			var scene, camera, renderer;
			var PI = 3.1416;
			var WIDTH, HEIGHT;

			var opening = false;
			var closing = false;
			var open = false;
			var clickingTop = false;

			var plane;
			var objects = [];
			var cover = new THREE.Object3D();
			var raycaster = new THREE.Raycaster();
			var mouseVector = new THREE.Vector2();
			var mouseUpVector = new THREE.Vector2();
			var mouseDownVector = new THREE.Vector2();
			var mouseMoveVector = new THREE.Vector2();
			var intersectsMouse;

			/**
	     * 
	     */
	    function init() {
	    	scene = new THREE.Scene();
	     	WIDTH = window.innerWidth;
				HEIGHT = window.innerHeight;

	      renderer = new THREE.WebGLRenderer({antialias:true});
	      renderer.setSize(WIDTH, HEIGHT);
	      document.body.appendChild(renderer.domElement);

	      camera = new THREE.PerspectiveCamera(45, WIDTH / HEIGHT, 0.1, 20000);
	      camera.position.set(2,2,2);
	      //camera.rotation.set(0,0,6);
	      scene.add(camera);

	      window.addEventListener('resize', function() {
	        WIDTH = window.innerWidth;
	        HEIGHT = window.innerHeight;
	        renderer.setSize(WIDTH, HEIGHT);
	        camera.aspect = WIDTH / HEIGHT;
	        camera.updateProjectionMatrix();
	      });

	      window.addEventListener( 'mousedown', onMouseDown );
				window.addEventListener( 'mouseup', onMouseUp );
				window.addEventListener( 'mousemove', onMouseMove);

	      renderer.setClearColor(0x333F47, 1);

				var ambientLight = new THREE.AmbientLight(0x999999);
				scene.add(ambientLight);

	      controls = new THREE.OrbitControls(camera, renderer.domElement);

	      createCube();
	      createCover();
	      optionListeners();
	    }

			/**
	     * 
	     */
	    function animate() {
	      requestAnimationFrame(animate);
	      renderer.render(scene, camera);
	      controls.update();

				if(opening && cover.rotation.x>0.25*PI){
					cover.rotation.x -= 0.02;
				}else if (opening){
					opening = false;
					open = true;
				}
				
				if(closing && cover.rotation.x<0.5*PI){
					cover.rotation.x += 0.02;
				}else if (closing){
					closing = false;
					open = false;
				}

	    }

	    /**
	     *
	     */	
	    function createCube() {
	    	var boxMaterial1 = new THREE.MeshPhongMaterial({ 
	    				side: THREE.FrontSide, 
	    		  	map: THREE.ImageUtils.loadTexture('img/cube/side.png') 
	    			});
				var boxMaterial2 = new THREE.MeshPhongMaterial({ 
							side: THREE.FrontSide, 
				  		map: THREE.ImageUtils.loadTexture('img/cube/side.png') 
						});
				var boxMaterial3 = new THREE.MeshPhongMaterial({ 
							side: THREE.FrontSide, 
							opacity: 0, 
							transparent: true, 
							map: THREE.ImageUtils.loadTexture('img/cube/top.png')
						});
				var boxMaterial4 = new THREE.MeshPhongMaterial({ 
							side: THREE.FrontSide, 
							map: THREE.ImageUtils.loadTexture('img/cube/side.png')
						});
				var boxMaterial5 = new THREE.MeshPhongMaterial({ 
							side: THREE.FrontSide, 
							map: THREE.ImageUtils.loadTexture('img/cube/front.png') 
						});
				var boxMaterial6 = new THREE.MeshPhongMaterial({ 
							side: THREE.FrontSide, 
							map: THREE.ImageUtils.loadTexture('img/cube/back.png') 
						});
				var boxMaterialBack = new THREE.MeshPhongMaterial({ 
							side: THREE.BackSide, 
							map: THREE.ImageUtils.loadTexture('img/cube/side.png') 
						});

				var boxMaterials = [
						boxMaterial1, 
						boxMaterial2, 
						boxMaterial3, 
						boxMaterial4, 
						boxMaterial5, 
						boxMaterial6,
						boxMaterialBack];

				var boxFaceMaterial = new THREE.MeshFaceMaterial( boxMaterials );
				var boxGeometry = new THREE.BoxGeometry( 1, 1, 1 );
		
				for (var i = 0, len = boxGeometry.faces.length; i < len; i++) {
					var face = boxGeometry.faces[i].clone();
							face.materialIndex = 6;
					boxGeometry.faces.push(face);
					boxGeometry.faceVertexUvs[0].push(boxGeometry.faceVertexUvs[0][i].slice(0));
				}

				var cube = new THREE.Mesh( boxGeometry, boxFaceMaterial );
				scene.add( cube );
	    }

	    /**
	     *
	     */
	    function createCover() {
				var planeGeom = new THREE.PlaneGeometry(1, 1, 2, 2);
				var planeMat1 = new THREE.MeshPhongMaterial({ 
							side: THREE.DoubleSide, 
							map: THREE.ImageUtils.loadTexture('img/cube/side.png') 
						});
				var planeMat2 = new THREE.MeshPhongMaterial({ 
							side: THREE.FrontSide, 
							map: THREE.ImageUtils.loadTexture('img/cube/top.png') 
						});			
				
				var planeMaterials = [
							planeMat1, 
							planeMat2 ];
				
				var planeFaceMaterial = new THREE.MeshFaceMaterial( planeMaterials );

				plane = new THREE.Mesh(planeGeom , planeMat1);
				plane.rotation.x=0;
				plane.position.x=0;
				plane.position.y=0;
				plane.position.z=0; 
				plane.applyMatrix( new THREE.Matrix4().makeTranslation( 0, 0.5, 0 ) );

				cover.add(plane);
				cover.position.y=0.5;
				cover.position.z=-0.5;
				cover.rotation.x = 0.5*PI;
				scene.add(cover);

				objects.push( cover );
	    }

	    /**
	     *
	     */
			function onMouseDown( e ) {
				mouseVector.x = 2 * (e.clientX / window.innerWidth) - 1;
				mouseVector.y = 1 - 2 * ( e.clientY / window.innerHeight );
				mouseDownVector.x = 2 * (e.clientX / window.innerWidth) - 1;
				mouseDownVector.y = 1 - 2 * ( e.clientY / window.innerHeight );
				raycaster.setFromCamera( mouseDownVector, camera );
				intersectsMouse = raycaster.intersectObjects( objects , true);
				if (intersectsMouse.length>0){
					if(intersectsMouse[0].object.position==plane.position){
						clickingTop = true;
					}
				}
			}
			
			/**
			 *
			 */
			function onMouseUp( e ) {
				mouseUpVector.x = 2 * (e.clientX / window.innerWidth) - 1;
				mouseUpVector.y = 1 - 2 * ( e.clientY / window.innerHeight );
				if (mouseDownVector.x == mouseUpVector.x && mouseDownVector.y == mouseUpVector.y){
					raycaster.setFromCamera( mouseDownVector, camera );
					var intersects = raycaster.intersectObjects( objects , true);
					if (intersects.length>0){
						if(intersects[0].object.position==plane.position && opening == false && open==false){
							opening = true;
						}
						if(intersects[0].object.position==plane.position && closing == false && open==true){
							closing = true;
						}
					}
				}
				clickingTop = false;
			}
			
			/**
			 *
			 */
			function onMouseMove (e){
				mouseMoveVector.x = 2 * (e.clientX / window.innerWidth) - 1;
				mouseMoveVector.y = 1 - 2 * ( e.clientY / window.innerHeight );
				if (mouseVector.x != mouseMoveVector.x && mouseVector.y != mouseMoveVector.y && clickingTop == true){
					if(mouseVector.y < mouseMoveVector.y && cover.rotation.x>0.25*3.1416){
						cover.rotation.x -= 0.1;
					}
					if(mouseVector.y > mouseMoveVector.y && cover.rotation.x<0.5*3.1416){
						cover.rotation.x += 0.1;
					}
				}
				mouseVector.x = 2 * (e.clientX / window.innerWidth) - 1;
				mouseVector.y = 1 - 2 * ( e.clientY / window.innerHeight );
			}

			/**
       *
			 */
			function optionListeners() {
				$(".automatic").click(function() {
					formatOptions();
					$( this ).css("background-color", "#fff");
				});
				$(".manual").click(function() {
					formatOptions();
					$( this ).css("background-color", "#fff");
				});
				$(".standard-object").click(function() {
					formatOptions();
					$( this ).css("background-color", "#fff");
				});
				$(".standard-x-axis").click(function() {
					formatOptions();
					$( this ).css("background-color", "#fff");
				});
				$(".bezier-object").click(function() {
					formatOptions();
					$( this ).css("background-color", "#fff");
				});
				$(".bezier-x-axis").click(function() {
					formatOptions();
					$( this ).css("background-color", "#fff");
				});
				$(".bezier-curve").click(function() {
					formatOptions();
					$( this ).css("background-color", "#fff");
				});
			}

			/**
			 *
			 */
			function formatOptions() {
				$(".option").each(function( index ) {
  				$( this ).css("background-color", "transparent");
				});
			}

			init();
			animate();
		</script>
	</body>
</html>